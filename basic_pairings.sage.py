

# This file was *autogenerated* from the file basic_pairings.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4965661367192848881 = Integer(4965661367192848881); _sage_const_6 = Integer(6); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_36 = Integer(36); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_18 = Integer(18); _sage_const_12 = Integer(12); _sage_const_9 = Integer(9); _sage_const_0 = Integer(0); _sage_const_11559732032986387107991004021392285783925812861821192530917403151452391805634 = Integer(11559732032986387107991004021392285783925812861821192530917403151452391805634); _sage_const_10857046999023057135944570762232829481370756359578518086990519993285655852781 = Integer(10857046999023057135944570762232829481370756359578518086990519993285655852781); _sage_const_4082367875863433681332203403145435568316851327593401208105741076214120093531 = Integer(4082367875863433681332203403145435568316851327593401208105741076214120093531); _sage_const_8495653923123431417604973247489272438418190587263600148770280649306958101930 = Integer(8495653923123431417604973247489272438418190587263600148770280649306958101930); _sage_const_10 = Integer(10); _sage_const_5 = Integer(5); _sage_const_30 = Integer(30); _sage_const_7 = Integer(7); _sage_const_42 = Integer(42)
from timeit import timeit
"""
Ref: https://theory.stanford.edu/~dfreeman/papers/ants-embedding.pdf (Example 3.6)
EC with embedding degree 10
q = 6462310997348816962203124910505252082673338846966431201635262694402825461643
A = -3
B = 4946538166640251374274628820269694144249181776013154863288086212076808528141
n = 6462310997348816962203124910505252082512561846156628595562776459306292101261
k = 10

assert(q.is_prime())
F = Zmod(q).field() # Zmod ring promoted to field since q is prime

assert((q ^ k - 1) % n == 0)

Chose not to use because computation of torsion subgroup is extremely slow.
"""

"""
BN curves (https://eprint.iacr.org/2005/133.pdf, https://eprint.iacr.org/2010/429.pdf)
p = p(u) = 36u^4 + 36u^3 + 24u^2 + 6u + 1
n = n(u) = 36u^4 + 36u^3 + 18u^2 + 6u + 1
for some u âˆˆ Z.
"""
class Pairing:
    """
    Bilinear pairing using tate pairing on BN curves over GF
    """

    def __init__(self, uu=_sage_const_4965661367192848881 ):
        """
        uu: The parameter value to BN curve trace, curve order, and characteristic of Fp. This value can be any integer that gives a prime order.
        """
        # BN curve parameters
        t = _sage_const_6 *uu**_sage_const_2  + _sage_const_1 
        r = _sage_const_36 *uu**_sage_const_4  + _sage_const_36 *uu**_sage_const_3  + _sage_const_18 *uu**_sage_const_2  + _sage_const_6 *uu + _sage_const_1 
        p = r + t - _sage_const_1 
        assert(p.is_prime())
        assert(r.is_prime())
        assert(p % _sage_const_4  == _sage_const_3 )
        k = _sage_const_12 

        self.p = p # base field prime order
        self.r = r # curve order
        self.k = k # embedding degree

        # https://hackmd.io/@vivi432/bn128-in-c
        Fp = GF(p)
        self.Fp = Fp

        P = Fp['x']; (x,) = P._first_ngens(1)
        Fp2 = Fp.extension(x**_sage_const_2  + _sage_const_1 , names=('u',)); (u,) = Fp2._first_ngens(1)
        self.Fp2 = Fp2

        zeta = u+_sage_const_9 
        assert(len(zeta.nth_root(_sage_const_2 , all=True)) == _sage_const_0 
               and len(zeta.nth_root(_sage_const_3 , all=True)) == _sage_const_0 )

        P = Fp2['t']; (t,) = P._first_ngens(1)
        Fp12 = Fp2.extension(t**_sage_const_6  - zeta, names=('w',)); (w,) = Fp12._first_ngens(1)
        self.Fp12 = Fp12

        assert(Fp.order() ** _sage_const_2  == Fp2.order() and Fp2.order() ** _sage_const_6  == Fp12.order())

        b1 = _sage_const_3 
        self.G1 = EllipticCurve(Fp, [_sage_const_0 , b1])
        assert(self.G1.order() == r)

        b2 = _sage_const_3  * zeta**(-_sage_const_1 )
        self.G2 = EllipticCurve(Fp2, [_sage_const_0 , b2])
        assert(self.G2.order() % r == _sage_const_0 )

        self.G12 = EllipticCurve(Fp12, [_sage_const_0 , b1])

        # Generators of the curves
        self.P = self.G1((_sage_const_1 , _sage_const_2 ))
        self.Q = self.G2((_sage_const_11559732032986387107991004021392285783925812861821192530917403151452391805634  * u
                          + _sage_const_10857046999023057135944570762232829481370756359578518086990519993285655852781 ,
                           _sage_const_4082367875863433681332203403145435568316851327593401208105741076214120093531  * u
                          + _sage_const_8495653923123431417604973247489272438418190587263600148770280649306958101930 ))

        self.m = r

        assert(self.m * self.P == _sage_const_0  and self.m * self.Q == _sage_const_0 )

        # Used for point twisting
        self.w = Fp12([_sage_const_0 , _sage_const_1 ] + [_sage_const_0 ] * _sage_const_10 )

    # https://github.com/ethereum/py_ecc/blob/a1d18addb439d7659a9cbac861bf1518371f0afd/py_ecc/bn128/bn128_curve.py#L129
    def twist(self, P):
        _x, _y = P.xy()
        _x, _y = _x.polynomial().coefficients(), _y.polynomial().coefficients()

        _x = _x + [_sage_const_0 ] * (_sage_const_2  - len(_x))
        _y = _y + [_sage_const_0 ] * (_sage_const_2  - len(_y))

        xcoeffs = [_x[_sage_const_0 ] - _x[_sage_const_1 ] * _sage_const_9 , _x[_sage_const_1 ]]
        ycoeffs = [_y[_sage_const_0 ] - _y[_sage_const_1 ] * _sage_const_9 , _y[_sage_const_1 ]]

        nx = self.Fp12([xcoeffs[_sage_const_0 ]] + [_sage_const_0 ] * _sage_const_5  + [xcoeffs[_sage_const_1 ]] + [_sage_const_0 ] * _sage_const_5 )
        ny = self.Fp12([ycoeffs[_sage_const_0 ]] + [_sage_const_0 ] * _sage_const_5  + [ycoeffs[_sage_const_1 ]] + [_sage_const_0 ] * _sage_const_5 )

        return self.G12((nx * self.w**_sage_const_2 , ny * self.w**_sage_const_3 ))

    def e(self, P, Q):
        if not (P.curve() == self.G1 and Q.curve() == self.G2):
            raise ValueError("Points do not lie on the curves defined")

        # Project both points to E(F_{p^12})
        Px = self.G12(P)
        Qx = self.twist(Q)

        assert(Px.parent() == Qx.parent())
        return Px.tate_pairing(Qx, self.m, self.k, q=self.p)

    def test(self):
        m = self.m
        Px, Qx = self.P, self.Q

        print(f"Testing with basis ({Px}, {Qx})")

        print("--- order m ---")
        Px2_Qx3 = self.e(_sage_const_2 *Px, _sage_const_3 *Qx)
        Px2_Qx3_m = Px2_Qx3 ** m
        print("e(2*Px, 3*Qx):", Px2_Qx3)
        print("e(2*Px, 3*Qx)^m:", Px2_Qx3_m)
        assert(Px2_Qx3_m == _sage_const_1 )

        print("--- non-degeneracy ---")
        Px_Qx = self.e(Px, Qx)
        assert(Px_Qx != _sage_const_1 )
        print("e(Px, Qx) =", Px_Qx)
        N = _sage_const_30 
        print("Average time of pairing:", timeit("self.e(Px, Qx)", globals=dict(globals(), **locals()), number=N)/N)

        print("--- bilinearity ---")
        Px6_Qx7 = self.e(_sage_const_6 *Px, _sage_const_7 *Qx)
        Px_Qx_42 = self.e(Px, Qx)**_sage_const_42 
        assert(Px6_Qx7 == Px_Qx_42)
        print("Tested e(6*Px, 7*Qx) == e(Px, Qx)^42")

        Px6_Qx = self.e(_sage_const_6 *Px, Qx)
        Px7_Qx = self.e(_sage_const_7 *Px, Qx)

        assert(Px7_Qx == Px6_Qx * Px_Qx)
        print("Tested e(7*Px, Qx) == e(6*Px, Qx) * e(Px, Qx)")

        Px_Qx6 = self.e(Px, _sage_const_6 *Qx)
        Px_Qx7 = self.e(Px, _sage_const_7 *Qx)
        assert(Px_Qx7 == Px_Qx * Px_Qx6)
        print("Tested e(Px, 7*Qx) == e(Px, Qx) * e(Px, 6*Qx)")



if __name__ == "__main__":
    pr = Pairing()
    pr.test()

