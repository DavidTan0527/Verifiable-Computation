

# This file was *autogenerated* from the file dotproduct.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_5 = Integer(5); _sage_const_100 = Integer(100); _sage_const_10 = Integer(10)
from itertools import islice
import secrets

def random_nonzero_element(G):
    return list(islice(filter(lambda x: x !=_sage_const_0  , (G.random_element() for _ in ZZ)), _sage_const_1 ))[_sage_const_0 ]

load('basic_pairings.sage')

class VerifiableDotProduct:
    def __init__(self, x):
        """
        x: Dot product vector. Type: sage vector object
        """
        self.dim = x.degree()
        self.x = x

        # function setup
        variables = ["x%d" % i for i in range(self.dim)]
        R = PolynomialRing(self.x.base_ring(), variables, order='lex')
        R.inject_variables(verbose=False)

        z = vector([eval(variables[i]) for i in range(N)])
        f = self.x.dot_product(z)
        self.f = f

    def keygen(self, T):
        """
        T: security parameter of the scheme
        u, m: parameters to the `Pairing` class

        Ran by model manager. Generates the key pair (PK, SK) with the parameters.
        """
        if T < _sage_const_1 :
            raise ValueError("Security parameter T must be a positive integer")

        pr = Pairing()
        G1 = pr.G1
        G2 = pr.G2
        G12 = pr.G12
        self.G1 = G1
        self.G2 = G2
        self.G12 = G12

        self.e = pr.e
        self.m = pr.m

        # Security requirement: q > 2^T
        q = secrets.choice(prime_range(_sage_const_2 **T + _sage_const_1 , _sage_const_2 **(_sage_const_2 *T)))
        self.q = q

        Zq = Zmod(q)
        self.Zq = Zq

        # random element in Z*_q
        s = random_nonzero_element(Zq)

        g = pr.P
        h = pr.Q

        gs = s * g
        g1 = G1.random_element()
        g2 = G1.random_element()

        # t = (t_1, t_2, ..., t_n) where t_i in Z*_q
        t = vector(Zq, [random_nonzero_element(Zq) for _ in range(self.dim)])

        W = [(t[i] * g1, t[i] * h) for i in range(self.dim)] + [sum(tt.lift()**_sage_const_2  for tt in t) * g1]

        PK = (q, G1, G2, G12, h, (g, gs), (g1, g2), W)
        SK = (s, t)

        # Note that in practice, the PK is not kept in the object, but passed in as it is public information.
        # We assign it to self to stick with the paper's function signatures
        self.pk = PK

        return PK, SK

    def setup(self, pk):
        """
        pk: Public Key generated by `keygen` method

        Ran by model manager. Setups the function `f` (dot product) with necessary algebraic structures.
        The function `f` is omitted from the parameters because it can be deduced from `x` in constructor.
        """
        q, G1, G2, G12, h, (g, gs), (g1, g2), W = pk
        assert(len(W) == len(self.x) + _sage_const_1 )

        fk = _sage_const_0 
        for (g1_t, h_t), xx in zip(W[:-_sage_const_1 ], self.x):
            fk += xx * g1_t

        return fk

    def encrypt(self, pk, z, r):
        """
        pk: Public Key generated by `keygen` method
        z : Input to `f` (dot product). Type: sage vector object
        r : Selected random vector to hide input information. Type: sage vector object

        Ran by the client (independent execution from model manager and service provider).
        Encrypts `z` with `pk` and a selected random `r`.
        """
        if z.degree() != self.dim:
            raise ArithmeticError("Cannot encrypt vector of size %d (expected %d)" % (z.degree(), self.dim))

        if z.degree() != self.dim:
            raise ArithmeticError("Cannot use vector of size %d in current encryption setup (expected %d)" % (len(z), self.dim))

        q, G1, G2, G12, h, (g, gs), (g1, g2), W = pk

        # { g1^zi, g^ri, g2^ri, g^(s*ri) }
        C = [(z[i] * g1 + r[i] * g, z[i] * g2 + r[i] * gs) for i in range(self.dim)]

        return C

    def compute(self, pk, C):
        """
        pk: Public key generated by `keygen`
        C : Ciphertext of input to calculate dot product of

        Ran by the service provider. `f` omitted because it is implied in the `setup`
        """
        q, G1, G2, G12, h, (g, gs), (g1, g2), W = pk

        V = (_sage_const_0 , _sage_const_0 )

        for xx, cc in zip(self.x, C):
            V = (V[_sage_const_0 ] + xx * cc[_sage_const_0 ], V[_sage_const_1 ] + xx * cc[_sage_const_1 ])

        d = random_nonzero_element(self.Zq)

        sgm0 = d * h
        self.sgm0 = sgm0

        sgm = []
        for (g1_t, h_t), xx in zip(W[:-_sage_const_1 ], self.x):
            sgm.append(d * (xx * g1 + g1_t))

        return (V, sgm)

    def decrypt(self, sk, V, bound):
        """
        sk: Secret Key generated by `keygen` method
        V : Encrypted output to be decrypted
        bound: Bound for solution to speed up discrete_log

        Ran by the model manager. Decrypts the computed (encrypted) output to the function output.
        """
        q, G1, G2, G12, h, (g, gs), (g1, g2), W = self.pk
        s, t = sk

        def pi(p): return s * p[_sage_const_0 ] - p[_sage_const_1 ]

        pi_V = pi(V)
        pi_g1_g2 = pi((g1, g2))

        # Find x such that x * pi((g1, g2)) == pi(V)
        return discrete_log_lambda(pi_V, pi_g1_g2, (_sage_const_0 , bound), operation='+')

    def verify(self, pk, fk, z, v, sgm):
        q, G1, G2, G12, h, (g, gs), (g1, g2), W = pk

        assert(len(W) == len(z) + _sage_const_1  and len(z) == len(sgm))

        H = W[-_sage_const_1 ]
        for (g1_t, h_t), zz in zip(W[:-_sage_const_1 ], z):
            H -= zz * g1_t

        verification = self.e(fk - v * g1 + H, self.sgm0)

        sgn = _sage_const_1 
        for (g1_t, h_t), zz, sgmi in zip(W[:-_sage_const_1 ], z, sgm):
            sgn *= self.e(sgmi, h_t - zz * h)

        # Check with pairing
        return verification == sgn

if __name__ == '__main__':
    N = _sage_const_5 
    UPPER_BOUND = _sage_const_100 
    Fv = ZZ
    x = vector(Fv, [secrets.randbelow(UPPER_BOUND) for _ in range(N)])
    print(f"Verifiable Dot Product for dimension {N} vectors with {x}")
    vdp = VerifiableDotProduct(x)

    print("1. KeyGen with T = 10")
    pk, sk = vdp.keygen(_sage_const_10 )
    print("G1 group size:", vdp.G1.order())
    print("PK:", pk)
    print("SK:", sk)
    print()

    # Define our dot product
    def f(z):
        return sum(xx * zz for xx, zz in zip(x, z))

    print("2. Setup function (public) key FK with PK and dot product function f")
    fk = vdp.setup(pk)
    print("FK:", fk)
    print()

    assert(fk.curve() == pk[_sage_const_5 ][_sage_const_0 ].curve()) # fk is in same group as g

    print("3. Encrypt an input z with PK and a chosen random r")
    r = vector(Fv, (secrets.randbelow(UPPER_BOUND) for _ in range(N)))
    print("r:", r)
    print("x:", x)
    z = vector(Fv, map(lambda xx : xx.strip(), input("z: ").split(",")))
    c = vdp.encrypt(pk, z, r)
    print("c:", c)
    print()

    print("4. Compute the dot product over the encrypted input z (also outputs signature)")
    V, sgm = vdp.compute(pk, c)
    print("V:", V)
    print("Ïƒ:", sgm)
    print()

    print("5. Decrypt the encrypted output to get the result of dot product")
    print("x * z:", f(z))
    v = vdp.decrypt(sk, V, N * UPPER_BOUND**_sage_const_2 )
    print("v:", v)
    print()
    assert(f(z) == v)

    print("6. Verify the signature")
    valid = vdp.verify(pk, fk, z, v, sgm)
    print("is valid?", valid)
    assert(valid)



