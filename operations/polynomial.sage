from itertools import islice
import secrets

def random_nonzero_element(G):
    return list(islice(filter(lambda x: x != 0 , (G.random_element() for _ in ZZ)), 1))[0]

class VerifiablePolynomial:
    def __init__(self, f):
        """
        f: Polynomial to compute. Type: sage Polynomial object
        """

        if f.degree() > 2:
            raise NotImplementedError("No support for polynomials of degree > 2")

        self.dim = f.degree() + 1
        self.f = f

    def keygen(self, T):
        """
        T: security parameter of the scheme

        Ran by model manager. Generates the key pair (PK, SK) with the parameters.
        """
        if T < 1:
            raise ValueError("Security parameter T must be a positive integer")

        pr = Pairing()
        G1 = pr.G1
        G2 = pr.G2
        G12 = pr.G12
        self.G1 = G1
        self.G2 = G2
        self.G12 = G12

        self.e = pr.e
        self.m = pr.m

        # Security requirement: q > 2^T
        q = secrets.choice(prime_range(2^T + 1, 2^(2*T)))
        self.q = q

        Zq = Zmod(q)
        s = random_nonzero_element(Zq)

        g = pr.P
        h = pr.Q

        gs = s * g
        g1 = G1.random_element()
        g2 = G1.random_element()

        # t = (t_1, t_2, ..., t_n) where t_i in Z*_q
        t = random_nonzero_element(Zq)

        # g^t for verification only
        W = [(t.lift()^d * g1, t.lift()^d * h) for d in range(1, self.dim)] + [t * g]

        PK = (q, G1, G2, G12, h, (g, gs), (g1, g2), W)
        SK = s

        # Note that in practice, the PK is not kept in the object, but passed in as it is public information.
        # We assign it to self to stick with the paper's function signatures
        self.pk = PK

        return PK, SK

    def setup(self, pk):
        """
        pk: Public Key generated by `keygen` method

        Ran by model manager. Setups the function `f` (dot product) with necessary algebraic structures.
        The function `f` is omitted from the parameters because it can be deduced from `x` in constructor.
        """
        q, G1, G2, G12, h, (g, gs), (g1, g2), W = pk
        assert(len(W) == self.dim)

        coeffs = self.f.coefficients()

        fk = coeffs[0] * g1
        for (g1_ti, h_ti), ci in zip(W[:self.dim-1], coeffs[1:]):
            fk += ci * g1_ti

        return fk

    def encrypt(self, pk, z):
        """
        pk: Public Key generated by `keygen` method
        z : Input to polynomial `f`.

        Ran by the client (independent execution from model manager and service provider).
        Encrypts `z` with `pk`.
        """
        q, G1, G2, G12, h, (g, gs), (g1, g2), W = pk

        # Kept for customer only
        r = [random_nonzero_element(Zmod(q)) for _ in range(self.dim - 1)]
        self.r = r

        # { g1^zi, g^ri, g2^ri, g^(s*ri) }
        C = [(z ^ i * g1 + r[i-1] * g, z ^ i * g2 + r[i-1] * gs) for i in range(1, self.dim)]

        return C

    def compute(self, pk, C):
        """
        pk: Public key generated by `keygen`
        C : Ciphertext of input to calculate dot product of

        Ran by the service provider. `f` omitted because it is implied in the `setup`
        """
        q, G1, G2, G12, h, (g, gs), (g1, g2), W = pk

        # Polynomial should be hidden. Shared usage here for generalization in code
        coeffs = self.f.coefficients()

        V = (coeffs[0] * g1, coeffs[0] * g2)

        for ci, cc in zip(coeffs[1:], C):
            V = (V[0] + ci * cc[0], V[1] + ci * cc[1])

        d = random_nonzero_element(Zmod(q))

        sgm0 = d * h
        self.sgm0 = sgm0

        g1_t = W[0][0]
        sgm = coeffs[1] * g1 + g1_t
        if self.f.degree() > 1:
            # g1^(t - z) g^r1
            sgm += coeffs[2] * (g1_t + C[0][0])

        sgm *= d

        return (V, sgm)

    def decrypt(self, sk, V, bound):
        """
        sk: Secret Key generated by `keygen` method
        V : Encrypted output to be decrypted
        bound: Bound for solution to speed up discrete_log

        Ran by the model manager. Decrypts the computed (encrypted) output to the function output.
        """
        q, G1, G2, G12, h, (g, gs), (g1, g2), W = self.pk
        s = sk

        def pi(p): return s * p[0] - p[1]

        pi_V = pi(V)
        pi_g1_g2 = pi((g1, g2))

        # Find x such that x * pi((g1, g2)) == pi(V)
        return discrete_log_lambda(pi_V, pi_g1_g2, (0, bound), operation='+')

    def verify(self, pk, fk, z, v, sgm):
        q, G1, G2, G12, h, (g, gs), (g1, g2), W = pk

        g1_t, h_t = W[0]
        g1_t2, h_t2 = W[1]
        g_t = W[-1]

        # Polynomial should be hidden. Shared usage here for generalization in code
        H = g1_t2 - z * g1_t
        if self.f.degree() > 1:
            H += self.f.coefficients()[2] * (self.r[0] * (g_t - z * g))

        verification = self.e(fk - v * g1 + H, self.sgm0)

        sgn = self.e(sgm, h_t - z * h)

        # Check with pairing
        return verification == sgn

