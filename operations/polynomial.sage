from itertools import islice
import secrets

def random_nonzero_element(G):
    return list(islice(filter(lambda x: x != 0 , (G.random_element() for _ in ZZ)), 1))[0]

class VerifiablePolynomial(MVP):
    def __init__(self, f):
        """
        f: Polynomial to compute. Type: sage Polynomial object
        """

        if f.degree() > 2:
            raise NotImplementedError("No support for polynomials of degree > 2")

        self.dim = f.degree() + 1
        self.f = f

    def getW(self, g1, g, h):
        # t = (t_1, t_2, ..., t_n) where t_i in Z*_q
        t = random_nonzero_element(Zmod(self.q))
        # g^t for verification only
        return [(t.lift()^d * g1, t.lift()^d * h) for d in range(1, self.dim)] + [t * g]

    def setup(self, pk):
        """
        pk: Public Key generated by `keygen` method

        Ran by model manager. Setups the function `f` (dot product) with necessary algebraic structures.
        The function `f` is omitted from the parameters because it can be deduced from `x` in constructor.
        """
        q, G1, G2, G12, h, (g, gs), (g1, g2), W, (n, g_n2) = pk
        assert(len(W) == self.dim)

        coeffs = self.f.coefficients(sparse=False)

        fk = coeffs[0] * g1
        for (g1_ti, h_ti), ci in zip(W[:self.dim-1], coeffs[1:]):
            fk += ci * g1_ti

        return fk

    def encrypt(self, pk, z):
        """
        pk: Public Key generated by `keygen` method
        z : Input to polynomial `f`.

        Ran by the client (independent execution from model manager and service provider).
        Encrypts `z` with `pk`.
        """
        Z = [z ^ i for i in range(1, self.dim)]
        return super().encrypt(pk, Z)

    def compute(self, pk, C):
        """
        pk: Public key generated by `keygen`
        C : Ciphertext of input to calculate dot product of

        Ran by the service provider. `f` omitted because it is implied in the `setup`
        """
        q, G1, G2, G12, h, (g, gs), (g1, g2), W, (n, g_n2) = pk
        C, Wc = C

        # Polynomial should be hidden. Shared usage here for generalization in code
        coeffs = self.f.coefficients(sparse=False)

        r = random_nonzero_element(Zmod(n^2))
        V = g_n2 ^ coeffs[0] * r ^ n

        for ci, cc in zip(coeffs[1:], C):
            V *= cc^ci

        d = random_nonzero_element(Zmod(q))

        sgm0 = d * h
        self.sgm0 = sgm0

        g1_t = W[0][0]
        sgm = coeffs[1] * g1 + g1_t
        if self.f.degree() > 1:
            # g1^a2(t + z) g^a2r1
            sgm += coeffs[2] * (g1_t + Wc[0])

        sgm *= d

        return (V, sgm)

    def decrypt(self, sk, V):
        """
        sk: Secret Key generated by `keygen` method
        V : Encrypted output to be decrypted
        bound: Bound for solution to speed up discrete_log

        Ran by the model manager. Decrypts the computed (encrypted) output to the function output.
        """
        return self.f.base_ring()(super().decrypt(sk, V))

    def verify(self, pk, fk, z, v, sgm):
        q, G1, G2, G12, h, (g, gs), (g1, g2), W, (n, g_n2) = pk

        g1_t, h_t = W[0]
        g1_t2, h_t2 = W[1]
        g_t = W[-1]

        # Polynomial should be hidden. Shared usage here for generalization in code
        H = g1_t2 - z * g1_t
        if self.f.degree() > 1:
            coeffs = self.f.coefficients(sparse=False)
            H += coeffs[2] * (self.r[0] * (g_t - z * g))

        verification = self.e(fk - v * g1 + H, self.sgm0)

        sgn = self.e(sgm, h_t - z * h)

        # Check with pairing
        return verification == sgn

